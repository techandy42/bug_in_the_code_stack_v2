{"id": "20240525024300819895_0dc46078732d4320838b0215bb7698e4", "name": "Incorrect Function Implementation", "documentation": "# This function calculates the square of the given number.\n# Input: 2, Output: 4\n# Input: -3, Output: 9\n# Input: 0, Output: 0\n# Input: 5, Output: 25\n# Input: -7, Output: 49", "code_with_bug": "def calculate_square(number):\n    return number * 3", "code_without_bug": "def calculate_square(number):\n    return number * number", "unit_tests": ["try:\n    result = calculate_square(2)\n    assert result == 4\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    result = calculate_square(-3)\n    assert result == 9\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    result = calculate_square(0)\n    assert result == 0\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    result = calculate_square(5)\n    assert result == 25\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    result = calculate_square(-7)\n    assert result == 49\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024304857632_59028f12a25c432ab2ea86c9d3d1a161", "name": "Incorrect Algorithm Implementation", "documentation": "# This function computes Fibonacci numbers.\n# Given an integer n, it returns the nth Fibonacci number.\n# Input: 0, Expected Output: 0\n# Input: 1, Expected Output: 1\n# Input: 2, Expected Output: 1\n# Input: 3, Expected Output: 2\n# Input: 10, Expected Output: 55", "code_with_bug": "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n", "code_without_bug": "def fibonacci(n):\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n", "unit_tests": ["try:\n    result = fibonacci(0)\n    assert result == 0\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    result = fibonacci(1)\n    assert result == 1\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    result = fibonacci(2)\n    assert result == 1\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    result = fibonacci(3)\n    assert result == 2\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    timeout_duration = 1\n    _ = run_with_timeout(fibonacci, timeout_duration, 10)\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024310548535_51ebdbe69a4a476691a483e69a0bcd8f", "name": "Unhandled Corner Cases", "documentation": "# This function calculates the integer square root of a number.\n# If the input is 16, the expected output is 4.\n# If the input is 15, the expected output is 3.\n# If the input is 0, the expected output is 0.\n# If the input is 1, the expected output is 1.\n# If the input is a negative number, it should raise a ValueError.", "code_with_bug": "def integer_square_root(n):\n    # Handle negative input\n    if n < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number\")\n    \n    # Implementing the integer square root algorithm\n    low, high = 0, n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return mid\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return high", "code_without_bug": "def integer_square_root(n):\n    # Handle negative input\n    if n < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number\")\n    \n    # Implementing the integer square root algorithm\n    low, high = 0, n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return mid\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low - 1", "unit_tests": ["try:\n    assert integer_square_root(16) == 4\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert integer_square_root(15) == 3\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert integer_square_root(0) == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert integer_square_root(1) == 1\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    integer_square_root(-1)\nexcept ValueError:\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024316338308_d0b5eca437d74e198329d124b4d02c34", "name": "Incorrect Usage of a Variable", "documentation": "# Function to calculate the factorial of a given non-negative integer.\n# Input: 5; Expected Output: 120\n# Input: 0; Expected Output: 1\n# Input: 3; Expected Output: 6\n# Input: -1; Expected Output: None\n# Input: 10; Expected Output: 3628800", "code_with_bug": "def factorial(n):\n    result = 1\n    if n < 0:\n        return None\n    for i in range(1, n + 1):\n        result += i  # BUG: should be result *= i\n    return result", "code_without_bug": "def factorial(n):\n    result = 1\n    if n < 0:\n        return None\n    for i in range(1, n + 1):\n        result *= i\n    return result", "unit_tests": ["try:\n    assert factorial(5) == 120\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert factorial(0) == 1\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert factorial(3) == 6\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert factorial(-1) == None\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert factorial(10) == 3628800\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024321203171_f0f82bc6dfb7484abdcbd7f56349ae01", "name": "Logic Errors in Conditional Statements", "documentation": "# The function determines if a given number is part of a predefined range (10, 20).\n# Sample Input: 15, Expected Output: True\n# Sample Input: 10, Expected Output: False\n# Sample Input: 20, Expected Output: False\n# Sample Input: 5, Expected Output: False\n# Sample Input: 25, Expected Output: False\n", "code_with_bug": "def is_in_range(number):\n    # This function checks if 'number' is within the range (10, 20)\n    if number > 10 and number <= 20:\n        return True\n    return False\n", "code_without_bug": "def is_in_range(number):\n    # This function checks if 'number' is within the range (10, 20)\n    if number > 10 and number < 20:\n        return True\n    return False\n", "unit_tests": ["try:\n    assert is_in_range(15) == True\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_in_range(10) == False\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_in_range(20) == False\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_in_range(5) == False\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_in_range(25) == False\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024326725372_3056ee1a31f74fb490155d89971e85fd", "name": "Infinite Loop", "documentation": "# This function returns the nth Fibonacci number.\n# Sample Input: 3\n# Expected Output: 2\n# Sample Input: 5\n# Expected Output: 5\n# Sample Input: 10\n# Expected Output: 55\n# Sample Input: 0\n# Expected Output: 0\n# Sample Input: 1\n# Expected Output: 1", "code_with_bug": "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib_prev, fib = 0, 1\n        i = 2\n        while True:\n            fib_prev, fib = fib, fib_prev + fib\n            i += 1\n            if i > n:  # Incorrect loop continuation condition causing infinite loop\n                break\n        return fib", "code_without_bug": "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib_prev, fib = 0, 1\n        i = 2\n        while i <= n:\n            fib_prev, fib = fib, fib_prev + fib\n            i += 1\n        return fib", "unit_tests": ["try:\n    assert fibonacci(3) == 2\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert fibonacci(5) == 5\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    timeout_duration = 1  # Timeout duration in seconds\n    def run_with_timeout(func, timeout, *args):\n        import time\n        import threading\n        result = []\n        def wrapper():\n            result.append(func(*args))\n        t = threading.Thread(target=wrapper)\n        t.start()\n        t.join(timeout)\n        if t.is_alive():\n            return 'FAILURE'\n        return 'SUCCESS'\n    _ = run_with_timeout(fibonacci, timeout_duration, 10)\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert fibonacci(0) == 0\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert fibonacci(1) == 1\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024333408522_20d0d2d79fd7434ca873bba89aa43af2", "name": "Infinite Recursion", "documentation": "# Purpose: Calculate the factorial of a given number\n# Sample Input: 0, Expected Output: 1\n# Sample Input: 5, Expected Output: 120\n# Sample Input: 7, Expected Output: 5040\n# Sample Input: 3, Expected Output: 6\n# Sample Input: 1, Expected Output: 1\n", "code_with_bug": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n)\n", "code_without_bug": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n", "unit_tests": ["try:\n    assert factorial(0) == 1\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    timeout_duration = 1\n    _ = run_with_timeout(factorial, timeout_duration, 5)\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    timeout_duration = 1\n    _ = run_with_timeout(factorial, timeout_duration, 7)\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    timeout_duration = 1\n    _ = run_with_timeout(factorial, timeout_duration, 3)\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert factorial(1) == 1\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024337700004_adfcf7086345430b8f2c77aec9b22ab5", "name": "Incorrect Loop Termination Condition", "documentation": "# This function counts the number of even numbers in a given list.\n# Sample input: [1, 2, 3, 4, 5], expected output: 2\n# Sample input: [2, 4, 6, 8], expected output: 4\n# Sample input: [1, 3, 5, 7], expected output: 0\n# Sample input: [], expected output: 0\n# Sample input: [0, 1, 0], expected output: 2", "code_with_bug": "def count_even_numbers(nums):\n    count = 0\n    for i in range(len(nums) + 1):  # Bug: This loop should terminate at len(nums)\n        if i < len(nums) and nums[i] % 2 == 0:\n            count += 1\n    return count", "code_without_bug": "def count_even_numbers(nums):\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] % 2 == 0:\n            count += 1\n    return count", "unit_tests": ["try:\n    nums = [1, 2, 3, 4, 5]\n    assert count_even_numbers(nums) == 2\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    nums = [2, 4, 6, 8]\n    assert count_even_numbers(nums) == 4\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    nums = [1, 3, 5, 7]\n    assert count_even_numbers(nums) == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    nums = []\n    assert count_even_numbers(nums) == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    nums = [0, 1, 0]\n    assert count_even_numbers(nums) == 2\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024344317889_5f8a6fc327cf4197a91b2ea2368ec762", "name": "Incorrect Type Conversion", "documentation": "#\n# This function concatenates a given string with a given number after converting the number to a string.\n# Input: str_value='Hello ', num_value=123 => Output: 'Hello 123'\n# Input: str_value='The price is ', num_value=99 => Output: 'The price is 99'\n# Input: str_value='', num_value=45 => Output: '45'\n# Input: str_value='Room number ', num_value=705 => Output: 'Room number 705'\n# Input: str_value='Error code ', num_value=404 => Output: 'Error code 404'\n#\n", "code_with_bug": "def concatenate_string_and_number(str_value, num_value):\n    \"\"\"\n    # This function concatenates a given string with a given number after converting the number to a string.\n    \"\"\"\n    return str_value + int(num_value)\n\n", "code_without_bug": "def concatenate_string_and_number(str_value, num_value):\n    \"\"\"\n    # This function concatenates a given string with a given number after converting the number to a string.\n    \"\"\"\n    return str_value + str(num_value)\n\n", "unit_tests": ["try:\n    assert concatenate_string_and_number('Hello ', 123) == 'Hello 123'\n    print('SUCCESS')\nexcept:\n    print('FAILURE')\n", "try:\n    assert concatenate_string_and_number('The price is ', 99) == 'The price is 99'\n    print('SUCCESS')\nexcept:\n    print('FAILURE')\n", "try:\n    assert concatenate_string_and_number('', 45) == '45'\n    print('SUCCESS')\nexcept:\n    print('FAILURE')\n", "try:\n    assert concatenate_string_and_number('Room number ', 705) == 'Room number 705'\n    print('SUCCESS')\nexcept:\n    print('FAILURE')\n", "try:\n    assert concatenate_string_and_number('Error code ', 404) == 'Error code 404'\n    print('SUCCESS')\nexcept:\n    print('FAILURE')\n"]}
{"id": "20240525024352072201_3a977b23546b4e1d8719d42cd728a66d", "name": "Floating Point Precision Error", "documentation": "# Function to compute the product of two floating point numbers, rounded to 2 decimal places.\n# Input: a = 1.12345, b = 2.34567; Output: 2.64\n# Input: a = 0.12345, b = 3.14159; Output: 0.39\n# Input: a = -1.98765, b = 2.54321; Output: -5.05\n# Input: a = 1.00001, b = 1.00001; Output: 1.00\n# Input: a = -0.55555, b = -1.44444; Output: 0.80\n", "code_with_bug": "def multiply_and_round(a, b):\n    result = a * b\n    # Bug: rounding to 3 decimal places instead of 2\n    return round(result, 3)\n", "code_without_bug": "def multiply_and_round(a, b):\n    result = a * b\n    # Correct rounding to 2 decimal places\n    return round(result, 2)\n", "unit_tests": ["try:\n    assert multiply_and_round(1.12345, 2.34567) == 2.64\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")\n", "try:\n    assert multiply_and_round(0.12345, 3.14159) == 0.39\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")\n", "try:\n    assert multiply_and_round(-1.98765, 2.54321) == -5.05\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")\n", "try:\n    assert multiply_and_round(1.00001, 1.00001) == 1.00\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")\n", "try:\n    assert multiply_and_round(-0.55555, -1.44444) == 0.80\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")\n"]}
{"id": "20240525024358123321_b0d6338f57664bf6864987964ab14539", "name": "Array Index Out of Bounds", "documentation": "# This function computes the sum of the first and last elements of an array.\n# It returns the sum if the array has at least one element.\n# If the input is [1, 2, 3], the output should be 4 (1+3).\n# If the input is [7], the output should be 14 (7+7).\n# If the input is [-5, 0, 5], the output should be 0 (-5+5).", "code_with_bug": "def sum_first_and_last(arr):\n    if len(arr) == 0:\n        raise ValueError(\"Array must contain at least one element.\")\n    return arr[0] + arr[len(arr)]  # BUG: should be arr[-1]", "code_without_bug": "def sum_first_and_last(arr):\n    if len(arr) == 0:\n        raise ValueError(\"Array must contain at least one element.\")\n    return arr[0] + arr[-1]", "unit_tests": ["try:\n    assert sum_first_and_last([1, 2, 3]) == 4\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert sum_first_and_last([7]) == 14\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert sum_first_and_last([]) == 0  # This should raise ValueError\n    print(\"FAILURE\")\nexcept:\n    print(\"SUCCESS\")", "try:\n    assert sum_first_and_last([1, -1, 1, -1]) == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    assert sum_first_and_last([-5, 0, 5]) == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024403639061_3c3c2d3729ba4923a3e75ea5a95307af", "name": "Dictionary Key Error", "documentation": "# Purpose: Filter a dictionary to only include keys that start with specify prefix.\n# Example: input_dict = {'a_1': 10, 'b_2': 20, 'a_2': 30}, prefix = 'a_'; output = {'a_1': 10, 'a_2': 30}\n# Example: input_dict = {'1': 1, '2': 2}, prefix = '1'; output = {'1': 1}\n# Example: input_dict = {}, prefix = 'a'; output = {}\n# Example: input_dict = {'key_1': 100}, prefix = 'key'; output = {'key_1': 100}\n# Example: input_dict = {'alpha': 1, 'beta': 2}, prefix = 'x'; output = {}\n", "code_with_bug": "def filter_dict_by_prefix(input_dict, prefix):\n    output = {}\n    for k in input_dict:\n        if k.startswith(prefix):\n            output[k] = input_dict['error']  # Bug: Accessing 'error' key instead of 'k'\n    return output\n", "code_without_bug": "def filter_dict_by_prefix(input_dict, prefix):\n    output = {}\n    for k in input_dict:\n        if k.startswith(prefix):\n            output[k] = input_dict[k]  # Correct: Accessing 'k'\n    return output\n", "unit_tests": ["try:\n    assert filter_dict_by_prefix({'a_1': 10, 'b_2': 20, 'a_2': 30}, 'a_') == {'a_1': 10, 'a_2': 30}\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert filter_dict_by_prefix({'1': 1, '2': 2}, '1') == {'1': 1}\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert filter_dict_by_prefix({}, 'a') == {}\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert filter_dict_by_prefix({'key_1': 100}, 'key') == {'key_1': 100}\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert filter_dict_by_prefix({'alpha': 1, 'beta': 2}, 'x') == {}\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024410065943_a11c8aa37dd145578e73e77958873ba6", "name": "Divide by Zero", "documentation": "# This function calculates the total distance traveled given speed and time.\n# Input: speed=50, time=2; Expected Output: 100\n# Input: speed=0, time=10; Expected Output: 0\n# Input: speed=25, time=4; Expected Output: 100\n# Input: speed=60, time=1; Expected Output: 60\n# Input: speed=30, time=3; Expected Output: 90", "code_with_bug": "def calculate_distance(speed, time):\n    # Bug here: speed divided by zero\n    return speed * time / 0", "code_without_bug": "def calculate_distance(speed, time):\n    return speed * time", "unit_tests": ["try:\n    assert calculate_distance(50, 2) == 100\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert calculate_distance(0, 10) == 0\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert calculate_distance(25, 4) == 100\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert calculate_distance(60, 1) == 60\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert calculate_distance(30, 3) == 90\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024415649528_8bbb7c48f6394f11882ac4cb383651bc", "name": "Incorrect Regular Expressions", "documentation": "# This function validates if the given email address is in a correct format.\n# For input 'example@example.com', the expected output is True.\n# For input 'user.name+tag+sorting@example.com', the expected output is True.\n# For input 'plainaddress', the expected output is False.\n# For input 'missing_at_symbol.com', the expected output is False.\n# For input '@missingusername.com', the expected output is False.", "code_with_bug": "import re\n\ndef is_valid_email(email):\n    \"\"\"\n    Validate the email address format using regular expression.\n    \"\"\"\n    # The pattern below has a bug: Domain part validation is incorrect\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}$\"\n    return re.match(pattern, email) is not None", "code_without_bug": "import re\n\ndef is_valid_email(email):\n    \"\"\"\n    Validate the email address format using regular expression.\n    \"\"\"\n    # Corrected pattern with valid domain part check\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]{2,}$\"\n    return re.match(pattern, email) is not None", "unit_tests": ["try:\n    assert is_valid_email('example@example.com') == True\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_valid_email('user.name+tag+sorting@example.com') == True\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_valid_email('plainaddress') == False\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_valid_email('missing_at_symbol.com') == False\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert is_valid_email('@missingusername.com') == False\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024422135799_6fb06410582b4395811af41ecbb4f5d1", "name": "Incorrect Handling of Date and Time", "documentation": "# This function calculates the number of days between two dates and returns the result.\n# Input: start_date = '2023-10-01', end_date = '2023-10-05'\n# Expected Output: 4\n# Input: start_date = '2021-12-31', end_date = '2022-01-01'\n# Expected Output: 1\n# Input: start_date = '2020-02-28', end_date = '2020-03-01'\n# Expected Output: 2\n# Input: start_date = '2019-03-01', end_date = '2019-03-10'\n# Expected Output: 9\n# Input: start_date = '2023-01-01', end_date = '2023-12-31'\n# Expected Output: 364", "code_with_bug": "from datetime import datetime\n\ndef days_between_dates(start_date: str, end_date: str) -> int:\n    \"\"\"\n    Calculate the number of days between two dates.\n    \"\"\"\n    start = datetime.strptime(start_date, '%Y-%m-%d')\n    end = datetime.strptime(end_date, '%Y-%m-%d')\n    delta = end - start\n    return delta.days - 1  # Bug: Incorrectly subtracts 1 day", "code_without_bug": "from datetime import datetime\n\ndef days_between_dates(start_date: str, end_date: str) -> int:\n    \"\"\"\n    Calculate the number of days between two dates.\n    \"\"\"\n    start = datetime.strptime(start_date, '%Y-%m-%d')\n    end = datetime.strptime(end_date, '%Y-%m-%d')\n    delta = end - start\n    return delta.days", "unit_tests": ["try:\n    assert days_between_dates('2023-10-01', '2023-10-05') == 4\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert days_between_dates('2021-12-31', '2022-01-01') == 1\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert days_between_dates('2020-02-28', '2020-03-01') == 2\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert days_between_dates('2019-03-01', '2019-03-10') == 9\n    print('SUCCESS')\nexcept:\n    print('FAILURE')", "try:\n    assert days_between_dates('2023-01-01', '2023-12-31') == 364\n    print('SUCCESS')\nexcept:\n    print('FAILURE')"]}
{"id": "20240525024430128115_39c03402c65348ea966c6e5b8fa1fae1", "name": "Incorrect Method Overriding in Subclasses", "documentation": "# This class definition demonstrates inheritance and method overriding.\n# Sample Input: Animal().speak(), Dog().speak()\n# Expected Output: 'Animal speaks', 'Dog barks'\n# Sample Input: A.method(), B:inherits_A().method(string)\n# Expected Output: 'Success overrides', 'Success inherits and overrides method with parameter type'\n# Sample Input: A().perform(), Dog().perform()\n# Expected Output: 'Generic Animal performs task', 'Dog fetches'\n# Sample Input: A().perform_task(), Dog().perform_task()\n# Expected Output: 'Animal performs task', 'Dog fetches'\n# Sample Input: A.method(), B.method()\n# Expected Output: 'Different', 'Different'", "code_with_bug": "class Animal:\n    def perform_task(self):\n        return \"Animal performs task\"\n\nclass Dog(Animal):\n    def perform_task(self, action):  # Incorrect Method Overriding\n        return \"Dog fetches\"\n", "code_without_bug": "class Animal:\n    def perform_task(self):\n        return \"Animal performs task\"\n\nclass Dog(Animal):\n    def perform_task(self):\n        return \"Dog fetches\"\n", "unit_tests": ["try:\n    a = Animal()\n    result = a.perform_task()\n    assert result == \"Animal performs task\"\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    d = Dog()\n    result = d.perform_task()\n    assert result == \"Dog fetches\"\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    a = Animal()\n    result = a.perform_task()\n    assert result == \"Animal performs task\"\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    d = Dog()\n    result = d.perform_task()\n    assert result == \"Dog fetches\"\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    a = Animal()\n    result = a.perform_task()\n    assert result == \"Animal performs task\"\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024439813524_9538df95f103452383e2c8d5a0f32770", "name": "Incorrect Use of super() in Inheritance", "documentation": "# This class represents a simple calculator that can add and multiply numbers.\n# Testing addition with inputs (1, 2) should return 3.\n# Testing addition with inputs (-1, 1) should return 0.\n# Testing multiplication with inputs (3, 5) should return 15.\n# Testing multiplication with inputs (0, 5) should return 0.\n# Testing the addition method with a timeout case.", "code_with_bug": "class Calculator:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def add(self):\n        return self.a + self.b\n\n    def multiply(self):\n        return self.a * self.b\n\nclass AdvancedCalculator(Calculator):\n    def __init__(self, a, b, c):\n        super(Calculator, self).__init__(a, b)\n        self.c = c\n\n    def add_all(self):\n        return self.a + self.b + self.c\n\n    def multiply_all(self):\n        return self.a * self.b * self.c", "code_without_bug": "class Calculator:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def add(self):\n        return self.a + self.b\n\n    def multiply(self):\n        return self.a * self.b\n\nclass AdvancedCalculator(Calculator):\n    def __init__(self, a, b, c):\n        super().__init__(a, b)\n        self.c = c\n\n    def add_all(self):\n        return self.a + self.b + self.c\n\n    def multiply_all(self):\n        return self.a * self.b * self.c", "unit_tests": ["try:\n    calc = AdvancedCalculator(1, 2, 3)\n    assert calc.add_all() == 6\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    calc = AdvancedCalculator(-1, 1, 2)\n    assert calc.add_all() == 2\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    calc = AdvancedCalculator(3, 5, 7)\n    assert calc.multiply_all() == 105\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    calc = AdvancedCalculator(0, 5, 10)\n    assert calc.multiply_all() == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    timeout_duration = 1\n    _ = run_with_timeout(AdvancedCalculator, timeout_duration, 1, 2, 3)\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024448469221_794a17baab7040d7ba8358bbd38b2758", "name": "Incorrect Use of Class Attributes", "documentation": "# This function demonstrates managing a counter using a class attribute.\n# Input Example: ExampleClass.increment(). Expected Output: Counter value incremented (1, 2, 3, etc.).\n# Input Example: ExampleClass.get_counter(). Expected Output: Current counter value.\n# Input Example: ExampleClass.reset_counter(). Expected Output: Counter reset to 0.\n# Input Example: ExampleClass.increment(), ExampleClass.increment(), ExampleClass.reset_counter(), ExampleClass.get_counter(). Expected Output: Counter reset to 0 after increments.\n# Input Example: ExampleClass.increment(), ExampleClass.get_counter(). Expected Output: Counter value incremented (1).", "code_with_bug": "class ExampleClass:\n    counter = 0\n\n    @classmethod\n    def increment(cls):\n        cls.counter += 1\n        return cls.counter\n\n    @classmethod\n    def reset_counter(cls):\n        cls.counter = 0\n\n    @classmethod\n    def get_counter(cls):\n        return cls.counter\n\n# Incorrect usage of class attribute\nclass UseExampleClass:\n    counter = ExampleClass.counter  # This incorrectly reuses the class attribute\n\n    @classmethod\n    def increment(cls):\n        cls.counter += 1\n        return cls.counter\n\n    @classmethod\n    def reset_counter(cls):\n        cls.counter = 0\n\n    @classmethod\n    def get_counter(cls):\n        return cls.counter", "code_without_bug": "class ExampleClass:\n    counter = 0\n\n    @classmethod\n    def increment(cls):\n        cls.counter += 1\n        return cls.counter\n\n    @classmethod\n    def reset_counter(cls):\n        cls.counter = 0\n\n    @classmethod\n    def get_counter(cls):\n        return cls.counter\n\nclass UseExampleClass:\n    @classmethod\n    def increment(cls):\n        ExampleClass.counter += 1\n        return ExampleClass.counter\n\n    @classmethod\n    def reset_counter(cls):\n        ExampleClass.reset_counter()\n\n    @classmethod\n    def get_counter(cls):\n        return ExampleClass.get_counter()", "unit_tests": ["try:\n    ExampleClass.reset_counter()\n    UseExampleClass.reset_counter()\n    assert UseExampleClass.increment() == 1\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    ExampleClass.reset_counter()\n    UseExampleClass.reset_counter()\n    UseExampleClass.increment()\n    assert UseExampleClass.increment() == 2\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    ExampleClass.reset_counter()\n    UseExampleClass.reset_counter()\n    assert UseExampleClass.get_counter() == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    ExampleClass.reset_counter()\n    UseExampleClass.reset_counter()\n    UseExampleClass.increment()\n    UseExampleClass.increment()\n    UseExampleClass.reset_counter()\n    assert UseExampleClass.get_counter() == 0\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    ExampleClass.reset_counter()\n    UseExampleClass.reset_counter()\n    UseExampleClass.increment()\n    assert UseExampleClass.get_counter() == 1\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024457601452_9b9575badf484cdba96780f67b748006", "name": "Incorrect Use of Class Methods & Instance Methods", "documentation": "# The Calculator class provides two methods to perform basic arithmetic operations\n# Inputs: 3, 5 \n# Output: 8 \n# Inputs: 6, 4 \n# Output: 24 \n# Inputs: 10, 2 \n# Output: 12 \n# Inputs: 15, 3 \n# Output: 18 \n# Inputs: 20, 5 \n# Output: 25", "code_with_bug": "class Calculator:\n    @classmethod\n    def add(cls, a, b):\n        return a + b\n\n    @classmethod\n    def multiply(cls, a, b):\n        return a * b", "code_without_bug": "class Calculator:\n    def add(self, a, b):\n        return a + b\n\n    def multiply(self, a, b):\n        return a * b", "unit_tests": ["try:\n    calc = Calculator()\n    assert calc.add(3, 5) == 8\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    calc = Calculator()\n    assert calc.multiply(6, 4) == 24\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    calc = Calculator()\n    assert calc.add(10, 2) == 12\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    calc = Calculator()\n    assert calc.multiply(15, 3) == 45\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    calc = Calculator()\n    assert calc.add(20, 5) == 25\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
{"id": "20240525024503805220_b801e1bc22d34ce6bcad47da6b24fa67", "name": "Incorrect Implementation of Comparison Methods", "documentation": "# This class defines a simple comparison between custom objects based on a value attribute\n# Example: obj1 = MyClass(1), obj2 = MyClass(2)\n# Sample Input: obj1 == obj2, Expected Output: False\n# Sample Input: obj1 < obj2, Expected Output: True\n# Sample Input: obj1 > obj2, Expected Output: False\n# Sample Input: obj1 != obj2, Expected Output: True\n# Sample Input: obj1 <= obj2, Expected Output: True\n# Sample Input: obj1 >= obj2, Expected Output: False", "code_with_bug": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __le__(self, other):\n        return self.value <= other.value\n\n    def __gt__(self, other):\n        return self.value <= other.value  # Bug here\n\n    def __ge__(self, other):\n        return self.value >= other.value", "code_without_bug": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __le__(self, other):\n        return self.value <= other.value\n\n    def __gt__(self, other):\n        return self.value > other.value\n\n    def __ge__(self, other):\n        return self.value >= other.value", "unit_tests": ["try:\n    obj1 = MyClass(1)\n    obj2 = MyClass(2)\n    assert (obj1 == obj2) == False\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    obj1 = MyClass(1)\n    obj2 = MyClass(2)\n    assert (obj1 < obj2) == True\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    obj1 = MyClass(1)\n    obj2 = MyClass(2)\n    assert (obj1 > obj2) == False\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    obj1 = MyClass(1)\n    obj2 = MyClass(2)\n    assert (obj1 != obj2) == True\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")", "try:\n    obj1 = MyClass(1)\n    obj2 = MyClass(1)\n    assert (obj1 <= obj2) == True\n    print(\"SUCCESS\")\nexcept:\n    print(\"FAILURE\")"]}
